package messagefactory

import (
	"reflect"
	"testing"
	"time"
	"xaal-go/device"
	"xaal-go/message"

	"github.com/stretchr/testify/assert"
)

func nowMock() time.Time {
	return time.Date(1977, 9, 22, 18, 20, 45, 651387237, time.UTC)
}

func Test_buildNonce(t *testing.T) {
	type args struct {
		data []int
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			name:    "Not empty",
			args:    args{data: []int{1539446691, 116932}},
			want:    []byte{0, 0, 0, 0, 91, 194, 23, 163, 0, 1, 200, 196},
			wantErr: false,
		},
		{
			name:    "Empty data",
			args:    args{data: nil},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := buildNonce(tt.args.data)
			if (err != nil) != tt.wantErr {
				t.Errorf("buildNonce() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("buildNonce() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_buildTimestamp(t *testing.T) {
	type args struct {
		nowTime func() time.Time
	}
	tests := []struct {
		name  string
		args  args
		want  int64
		want1 int64
	}{
		{
			args:  args{nowTime: nowMock},
			want:  243800445,
			want1: 651387,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, got1 := buildTimestamp(tt.args.nowTime)
			if got != tt.want {
				t.Errorf("buildTimestamp() got = %v, want %v", got, tt.want)
			}
			if got1 != tt.want1 {
				t.Errorf("buildTimestamp() got1 = %v, want %v", got1, tt.want1)
			}
		})
	}
}

func Test_encodeMsg(t *testing.T) {
	msg := message.Message{Body: map[string]interface{}{"bool": true, "int": 10, "string": "test", "array": []string{"A", "B"}}, Header: message.Header{Source: "3cd47760-ce4f-11e8-a044-406c8f5172cb", DevType: "test.basic", MsgType: "notify", Action: "alive"}, Targets: []string{}, Timestamp: []int{243800445, 651387}, Version: "0.5"}
	data := []byte{0x7b, 0x22, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x30, 0x2e, 0x35, 0x22, 0x2c, 0x22, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73, 0x22, 0x3a, 0x22, 0x5b, 0x5d, 0x22, 0x2c, 0x22, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x5b, 0x32, 0x34, 0x33, 0x38, 0x30, 0x30, 0x34, 0x34, 0x35, 0x2c, 0x36, 0x35, 0x31, 0x33, 0x38, 0x37, 0x5d, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x57, 0x46, 0x6c, 0x6e, 0x52, 0x4c, 0x7a, 0x67, 0x39, 0x30, 0x63, 0x55, 0x74, 0x36, 0x63, 0x78, 0x35, 0x52, 0x53, 0x54, 0x78, 0x2f, 0x34, 0x63, 0x51, 0x6e, 0x75, 0x6d, 0x7a, 0x68, 0x4d, 0x2f, 0x77, 0x52, 0x6e, 0x31, 0x6c, 0x41, 0x77, 0x6c, 0x48, 0x49, 0x54, 0x51, 0x54, 0x64, 0x74, 0x58, 0x44, 0x30, 0x47, 0x4e, 0x4b, 0x72, 0x5a, 0x66, 0x6c, 0x51, 0x64, 0x51, 0x4f, 0x66, 0x52, 0x36, 0x39, 0x4d, 0x49, 0x65, 0x4d, 0x73, 0x72, 0x44, 0x39, 0x7a, 0x64, 0x64, 0x69, 0x32, 0x64, 0x75, 0x52, 0x51, 0x2b, 0x69, 0x52, 0x32, 0x62, 0x4a, 0x56, 0x70, 0x4d, 0x71, 0x52, 0x67, 0x67, 0x41, 0x6a, 0x45, 0x38, 0x58, 0x2f, 0x32, 0x62, 0x50, 0x4e, 0x71, 0x74, 0x64, 0x4f, 0x68, 0x67, 0x73, 0x77, 0x6e, 0x54, 0x42, 0x34, 0x36, 0x52, 0x48, 0x74, 0x41, 0x45, 0x54, 0x50, 0x35, 0x76, 0x42, 0x7a, 0x69, 0x43, 0x52, 0x6c, 0x34, 0x75, 0x51, 0x53, 0x30, 0x55, 0x48, 0x4f, 0x2b, 0x72, 0x66, 0x6e, 0x66, 0x4f, 0x72, 0x73, 0x5a, 0x2f, 0x34, 0x72, 0x53, 0x42, 0x2b, 0x78, 0x64, 0x61, 0x4f, 0x51, 0x46, 0x66, 0x51, 0x54, 0x42, 0x42, 0x4e, 0x6b, 0x54, 0x4e, 0x76, 0x6b, 0x47, 0x63, 0x39, 0x64, 0x55, 0x32, 0x64, 0x2b, 0x6d, 0x74, 0x48, 0x77, 0x7a, 0x61, 0x37, 0x77, 0x63, 0x30, 0x44, 0x4c, 0x33, 0x39, 0x4a, 0x47, 0x61, 0x4d, 0x30, 0x42, 0x69, 0x4b, 0x2b, 0x74, 0x42, 0x37, 0x32, 0x72, 0x7a, 0x76, 0x72, 0x50, 0x4f, 0x6c, 0x6e, 0x46, 0x55, 0x42, 0x43, 0x36, 0x65, 0x38, 0x76, 0x72, 0x69, 0x50, 0x5a, 0x4c, 0x42, 0x4d, 0x33, 0x74, 0x57, 0x6a, 0x6e, 0x2b, 0x36, 0x68, 0x67, 0x33, 0x6c, 0x2f, 0x63, 0x64, 0x4a, 0x59, 0x75, 0x75, 0x36, 0x71, 0x64, 0x2b, 0x32, 0x6c, 0x41, 0x71, 0x61, 0x4b, 0x41, 0x55, 0x4e, 0x6e, 0x56, 0x52, 0x38, 0x64, 0x55, 0x77, 0x4c, 0x36, 0x2b, 0x4f, 0x58, 0x71, 0x51, 0x35, 0x51, 0x3d, 0x3d, 0x22, 0x7d}
	type args struct {
		msg     message.Message
		nowTime func() time.Time
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			name:    "Correct message",
			args:    args{msg: msg, nowTime: nowMock},
			want:    data,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := encodeMsg(tt.args.msg, tt.args.nowTime)
			if (err != nil) != tt.wantErr {
				t.Errorf("encodeMsg() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got, "they should be equal")
		})
	}
}

func Test_decodeMsg(t *testing.T) {
	msg := &message.Message{Body: map[string]interface{}{"bool": true, "int": float64(10), "string": "test", "array": []interface{}{"A", "B"}}, Header: message.Header{Source: "3cd47760-ce4f-11e8-a044-406c8f5172cb", DevType: "test.basic", MsgType: "notify", Action: "alive"}, Targets: []string{}, Timestamp: []int{243800445, 651387}, Version: "0.5"}
	data := []byte{0x7b, 0x22, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x30, 0x2e, 0x35, 0x22, 0x2c, 0x22, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73, 0x22, 0x3a, 0x22, 0x5b, 0x5d, 0x22, 0x2c, 0x22, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x5b, 0x32, 0x34, 0x33, 0x38, 0x30, 0x30, 0x34, 0x34, 0x35, 0x2c, 0x36, 0x35, 0x31, 0x33, 0x38, 0x37, 0x5d, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x57, 0x46, 0x6c, 0x6e, 0x52, 0x4c, 0x7a, 0x67, 0x39, 0x30, 0x63, 0x55, 0x74, 0x36, 0x63, 0x78, 0x35, 0x52, 0x53, 0x54, 0x78, 0x2f, 0x34, 0x63, 0x51, 0x6e, 0x75, 0x6d, 0x7a, 0x68, 0x4d, 0x2f, 0x77, 0x52, 0x6e, 0x31, 0x6c, 0x41, 0x77, 0x6c, 0x48, 0x49, 0x54, 0x51, 0x54, 0x64, 0x74, 0x58, 0x44, 0x30, 0x47, 0x4e, 0x4b, 0x72, 0x5a, 0x66, 0x6c, 0x51, 0x64, 0x51, 0x4f, 0x66, 0x52, 0x36, 0x39, 0x4d, 0x49, 0x65, 0x4d, 0x73, 0x72, 0x44, 0x39, 0x7a, 0x64, 0x64, 0x69, 0x32, 0x64, 0x75, 0x52, 0x51, 0x2b, 0x69, 0x52, 0x32, 0x62, 0x4a, 0x56, 0x70, 0x4d, 0x71, 0x52, 0x67, 0x67, 0x41, 0x6a, 0x45, 0x38, 0x58, 0x2f, 0x32, 0x62, 0x50, 0x4e, 0x71, 0x74, 0x64, 0x4f, 0x68, 0x67, 0x73, 0x77, 0x6e, 0x54, 0x42, 0x34, 0x36, 0x52, 0x48, 0x74, 0x41, 0x45, 0x54, 0x50, 0x35, 0x76, 0x42, 0x7a, 0x69, 0x43, 0x52, 0x6c, 0x34, 0x75, 0x51, 0x53, 0x30, 0x55, 0x48, 0x4f, 0x2b, 0x72, 0x66, 0x6e, 0x66, 0x4f, 0x72, 0x73, 0x5a, 0x2f, 0x34, 0x72, 0x53, 0x42, 0x2b, 0x78, 0x64, 0x61, 0x4f, 0x51, 0x46, 0x66, 0x51, 0x54, 0x42, 0x42, 0x4e, 0x6b, 0x54, 0x4e, 0x76, 0x6b, 0x47, 0x63, 0x39, 0x64, 0x55, 0x32, 0x64, 0x2b, 0x6d, 0x74, 0x48, 0x77, 0x7a, 0x61, 0x37, 0x77, 0x63, 0x30, 0x44, 0x4c, 0x33, 0x39, 0x4a, 0x47, 0x61, 0x4d, 0x30, 0x42, 0x69, 0x4b, 0x2b, 0x74, 0x42, 0x37, 0x32, 0x72, 0x7a, 0x76, 0x72, 0x50, 0x4f, 0x6c, 0x6e, 0x46, 0x55, 0x42, 0x43, 0x36, 0x65, 0x38, 0x76, 0x72, 0x69, 0x50, 0x5a, 0x4c, 0x42, 0x4d, 0x33, 0x74, 0x57, 0x6a, 0x6e, 0x2b, 0x36, 0x68, 0x67, 0x33, 0x6c, 0x2f, 0x63, 0x64, 0x4a, 0x59, 0x75, 0x75, 0x36, 0x71, 0x64, 0x2b, 0x32, 0x6c, 0x41, 0x71, 0x61, 0x4b, 0x41, 0x55, 0x4e, 0x6e, 0x56, 0x52, 0x38, 0x64, 0x55, 0x77, 0x4c, 0x36, 0x2b, 0x4f, 0x58, 0x71, 0x51, 0x35, 0x51, 0x3d, 0x3d, 0x22, 0x7d}
	// +120 seconds
	// msgYoung := message.Message{Body:map[string]interface {}{"bool":true, "int":10, "string":"test"}, Header:message.Header{Source:"3cd47760-ce4f-11e8-a044-406c8f5172cb", DevType:"test.basic", MsgType:"notify", Action:"alive"}, Targets:[]string{}, Timestamp:[]int{243800565, 651387}, Version:"0.5"}
	//	dataYoung := []byte{0x7b, 0x22, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x30, 0x2e, 0x35, 0x22, 0x2c, 0x22, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73, 0x22, 0x3a, 0x22, 0x5b, 0x5d, 0x22, 0x2c, 0x22, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x5b, 0x32, 0x34, 0x33, 0x38, 0x30, 0x30, 0x35, 0x36, 0x35, 0x2c, 0x36, 0x35, 0x31, 0x33, 0x38, 0x37, 0x5d, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x63, 0x59, 0x75, 0x73, 0x6b, 0x55, 0x75, 0x58, 0x63, 0x33, 0x4c, 0x4c, 0x57, 0x38, 0x2b, 0x44, 0x6c, 0x62, 0x4e, 0x54, 0x68, 0x4e, 0x57, 0x4d, 0x2b, 0x63, 0x4b, 0x4a, 0x6a, 0x66, 0x52, 0x49, 0x47, 0x6d, 0x35, 0x4e, 0x73, 0x46, 0x59, 0x70, 0x44, 0x62, 0x71, 0x62, 0x6b, 0x45, 0x32, 0x7a, 0x39, 0x65, 0x67, 0x70, 0x57, 0x62, 0x6f, 0x45, 0x50, 0x67, 0x54, 0x67, 0x71, 0x55, 0x44, 0x69, 0x79, 0x58, 0x55, 0x66, 0x4e, 0x44, 0x4c, 0x6d, 0x41, 0x31, 0x35, 0x63, 0x47, 0x79, 0x69, 0x51, 0x56, 0x4a, 0x6d, 0x35, 0x2f, 0x4d, 0x48, 0x54, 0x33, 0x58, 0x55, 0x36, 0x6f, 0x54, 0x4e, 0x68, 0x64, 0x33, 0x2f, 0x37, 0x7a, 0x4c, 0x31, 0x6a, 0x61, 0x53, 0x76, 0x38, 0x70, 0x48, 0x51, 0x42, 0x79, 0x71, 0x46, 0x74, 0x59, 0x52, 0x7a, 0x6b, 0x59, 0x61, 0x5a, 0x55, 0x7a, 0x77, 0x63, 0x50, 0x44, 0x34, 0x68, 0x58, 0x30, 0x7a, 0x45, 0x4e, 0x66, 0x75, 0x30, 0x50, 0x51, 0x58, 0x6f, 0x38, 0x37, 0x79, 0x30, 0x35, 0x44, 0x43, 0x42, 0x51, 0x64, 0x31, 0x33, 0x54, 0x67, 0x76, 0x4c, 0x34, 0x4a, 0x44, 0x66, 0x77, 0x42, 0x31, 0x48, 0x54, 0x56, 0x78, 0x77, 0x61, 0x4b, 0x7a, 0x70, 0x4d, 0x65, 0x41, 0x64, 0x75, 0x6e, 0x42, 0x56, 0x63, 0x59, 0x67, 0x62, 0x47, 0x49, 0x58, 0x67, 0x57, 0x55, 0x4f, 0x67, 0x72, 0x61, 0x75, 0x4b, 0x47, 0x30, 0x31, 0x6c, 0x58, 0x52, 0x69, 0x6d, 0x4a, 0x4a, 0x7a, 0x48, 0x58, 0x43, 0x6a, 0x49, 0x35, 0x6a, 0x65, 0x61, 0x55, 0x75, 0x5a, 0x73, 0x74, 0x4b, 0x72, 0x66, 0x68, 0x6a, 0x59, 0x47, 0x47, 0x69, 0x34, 0x34, 0x31, 0x66, 0x42, 0x4c, 0x58, 0x7a, 0x77, 0x3d, 0x3d, 0x22, 0x7d}
	// -120 seconds
	// msgOld := message.Message{Body:map[string]interface {}{"bool":true, "int":10, "string":"test"}, Header:message.Header{Source:"3cd47760-ce4f-11e8-a044-406c8f5172cb", DevType:"test.basic", MsgType:"notify", Action:"alive"}, Targets:[]string{}, Timestamp:[]int{243800325, 651387}, Version:"0.5"}
	//	dataOld := []byte{0x7b, 0x22, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x30, 0x2e, 0x35, 0x22, 0x2c, 0x22, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73, 0x22, 0x3a, 0x22, 0x5b, 0x5d, 0x22, 0x2c, 0x22, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x5b, 0x32, 0x34, 0x33, 0x38, 0x30, 0x30, 0x33, 0x32, 0x35, 0x2c, 0x36, 0x35, 0x31, 0x33, 0x38, 0x37, 0x5d, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x71, 0x76, 0x69, 0x42, 0x72, 0x79, 0x53, 0x34, 0x4e, 0x34, 0x59, 0x4d, 0x78, 0x46, 0x2b, 0x51, 0x79, 0x76, 0x66, 0x46, 0x43, 0x77, 0x44, 0x61, 0x6a, 0x2b, 0x74, 0x63, 0x51, 0x4c, 0x64, 0x76, 0x46, 0x57, 0x56, 0x73, 0x52, 0x45, 0x70, 0x6e, 0x2f, 0x45, 0x45, 0x75, 0x46, 0x45, 0x74, 0x68, 0x72, 0x75, 0x45, 0x74, 0x47, 0x43, 0x65, 0x39, 0x41, 0x54, 0x4b, 0x72, 0x41, 0x67, 0x53, 0x59, 0x67, 0x4f, 0x52, 0x75, 0x57, 0x50, 0x6f, 0x73, 0x70, 0x71, 0x39, 0x65, 0x43, 0x77, 0x2f, 0x58, 0x47, 0x30, 0x46, 0x77, 0x45, 0x63, 0x2f, 0x6f, 0x71, 0x41, 0x36, 0x2f, 0x58, 0x41, 0x64, 0x58, 0x30, 0x42, 0x71, 0x38, 0x42, 0x57, 0x77, 0x75, 0x56, 0x42, 0x50, 0x31, 0x4f, 0x49, 0x4b, 0x78, 0x36, 0x70, 0x74, 0x69, 0x69, 0x54, 0x4f, 0x4b, 0x45, 0x4b, 0x37, 0x4b, 0x6a, 0x69, 0x55, 0x31, 0x5a, 0x32, 0x4c, 0x6e, 0x4c, 0x76, 0x39, 0x6d, 0x71, 0x37, 0x66, 0x39, 0x79, 0x53, 0x2b, 0x34, 0x4b, 0x71, 0x2b, 0x4c, 0x4d, 0x39, 0x47, 0x4d, 0x64, 0x46, 0x6b, 0x63, 0x34, 0x72, 0x70, 0x5a, 0x56, 0x5a, 0x47, 0x39, 0x72, 0x38, 0x4d, 0x57, 0x52, 0x38, 0x2b, 0x62, 0x43, 0x7a, 0x42, 0x32, 0x61, 0x51, 0x78, 0x5a, 0x31, 0x67, 0x76, 0x39, 0x66, 0x44, 0x2b, 0x70, 0x30, 0x66, 0x41, 0x41, 0x4e, 0x7a, 0x6c, 0x45, 0x66, 0x6b, 0x62, 0x70, 0x71, 0x53, 0x57, 0x39, 0x73, 0x39, 0x48, 0x69, 0x55, 0x58, 0x62, 0x55, 0x51, 0x70, 0x4a, 0x6f, 0x61, 0x4f, 0x38, 0x6f, 0x63, 0x44, 0x77, 0x7a, 0x66, 0x4a, 0x38, 0x6f, 0x74, 0x69, 0x6e, 0x38, 0x70, 0x73, 0x48, 0x68, 0x54, 0x36, 0x44, 0x57, 0x4b, 0x51, 0x3d, 0x3d, 0x22, 0x7d}

	type args struct {
		data    []byte
		nowTime func() time.Time
	}
	tests := []struct {
		name    string
		args    args
		want    *message.Message
		wantErr bool
	}{
		{
			name:    "Correct data",
			args:    args{data: data, nowTime: nowMock},
			want:    msg,
			wantErr: false,
		}, /*
			{
				name:    "Young data",
				args:    args{data: dataYoung, nowTime: nowMock},
				wantErr: true,
			},
			{
				name:    "Old data",
				args:    args{data: dataOld, nowTime: nowMock},
				wantErr: true,
			},*/
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := decodeMsg(tt.args.data, tt.args.nowTime)
			if (err != nil) != tt.wantErr {
				t.Errorf("decodeMsg() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got, "they should be equal")
		})
	}
}

func TestBuildMsg(t *testing.T) {
	dev, _ := device.New("test.basic", "3cd47760-ce4f-11e8-a044-406c8f5172cb")
	body := make(map[string]interface{})
	body["bool"] = true
	body["int"] = 10
	body["string"] = "test"
	body["array"] = []string{"A", "B"}
	type args struct {
		dev     *device.Device
		targets []string
		msgtype string
		action  string
		body    map[string]interface{}
		nowTime func() time.Time
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "Good",
			args: args{
				dev:     dev,
				targets: []string{},
				msgtype: "notify",
				action:  "alive",
				body:    body,
				nowTime: nowMock,
			},
			want: []byte{0x7b, 0x22, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x30, 0x2e, 0x35, 0x22, 0x2c, 0x22, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73, 0x22, 0x3a, 0x22, 0x5b, 0x5d, 0x22, 0x2c, 0x22, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x5b, 0x32, 0x34, 0x33, 0x38, 0x30, 0x30, 0x34, 0x34, 0x35, 0x2c, 0x36, 0x35, 0x31, 0x33, 0x38, 0x37, 0x5d, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x57, 0x46, 0x6c, 0x6e, 0x52, 0x4c, 0x7a, 0x67, 0x39, 0x30, 0x63, 0x55, 0x74, 0x36, 0x63, 0x78, 0x35, 0x52, 0x53, 0x54, 0x78, 0x2f, 0x34, 0x63, 0x51, 0x6e, 0x75, 0x6d, 0x7a, 0x68, 0x4d, 0x2f, 0x77, 0x52, 0x6e, 0x31, 0x6c, 0x41, 0x77, 0x6c, 0x48, 0x49, 0x54, 0x51, 0x54, 0x64, 0x74, 0x58, 0x44, 0x30, 0x47, 0x4e, 0x4b, 0x72, 0x5a, 0x66, 0x6c, 0x51, 0x64, 0x51, 0x4f, 0x66, 0x52, 0x36, 0x39, 0x4d, 0x49, 0x65, 0x4d, 0x73, 0x72, 0x44, 0x39, 0x7a, 0x64, 0x64, 0x69, 0x32, 0x64, 0x75, 0x52, 0x51, 0x2b, 0x69, 0x52, 0x32, 0x62, 0x4a, 0x56, 0x70, 0x4d, 0x71, 0x52, 0x67, 0x67, 0x41, 0x6a, 0x45, 0x38, 0x58, 0x2f, 0x32, 0x62, 0x50, 0x4e, 0x71, 0x74, 0x64, 0x4f, 0x68, 0x67, 0x73, 0x77, 0x6e, 0x54, 0x42, 0x34, 0x36, 0x52, 0x48, 0x74, 0x41, 0x45, 0x54, 0x50, 0x35, 0x76, 0x42, 0x7a, 0x69, 0x43, 0x52, 0x6c, 0x34, 0x75, 0x51, 0x53, 0x30, 0x55, 0x48, 0x4f, 0x2b, 0x72, 0x66, 0x6e, 0x66, 0x4f, 0x72, 0x73, 0x5a, 0x2f, 0x34, 0x72, 0x53, 0x42, 0x2b, 0x78, 0x64, 0x61, 0x4f, 0x51, 0x46, 0x66, 0x51, 0x54, 0x42, 0x42, 0x4e, 0x6b, 0x54, 0x4e, 0x76, 0x6b, 0x47, 0x63, 0x39, 0x64, 0x55, 0x32, 0x64, 0x2b, 0x6d, 0x74, 0x48, 0x77, 0x7a, 0x61, 0x37, 0x77, 0x63, 0x30, 0x44, 0x4c, 0x33, 0x39, 0x4a, 0x47, 0x61, 0x4d, 0x30, 0x42, 0x69, 0x4b, 0x2b, 0x74, 0x42, 0x37, 0x32, 0x72, 0x7a, 0x76, 0x72, 0x50, 0x4f, 0x6c, 0x6e, 0x46, 0x55, 0x42, 0x43, 0x36, 0x65, 0x38, 0x76, 0x72, 0x69, 0x50, 0x5a, 0x4c, 0x42, 0x4d, 0x33, 0x74, 0x57, 0x6a, 0x6e, 0x2b, 0x36, 0x68, 0x67, 0x33, 0x6c, 0x2f, 0x63, 0x64, 0x4a, 0x59, 0x75, 0x75, 0x36, 0x71, 0x64, 0x2b, 0x32, 0x6c, 0x41, 0x71, 0x61, 0x4b, 0x41, 0x55, 0x4e, 0x6e, 0x56, 0x52, 0x38, 0x64, 0x55, 0x77, 0x4c, 0x36, 0x2b, 0x4f, 0x58, 0x71, 0x51, 0x35, 0x51, 0x3d, 0x3d, 0x22, 0x7d},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, _ := buildMsg(tt.args.dev, tt.args.targets, tt.args.msgtype, tt.args.action, tt.args.body, tt.args.nowTime)
			assert.Equal(t, tt.want, got, "should be equal")
		})
	}
}
